import { EventEmitter } from './event-emitter';
import { marketMonitor } from './market-monitor';
import { logService } from './log-service';
import { exchangeService } from './exchange-service';

export class AIService extends EventEmitter {
  private static instance: AIService;
  private TIMEOUT = 60000; // 60 seconds timeout

  private constructor() {
    super();
  }

  static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService();
    }
    return AIService.instance;
  }

  /**
   * Analyzes market conditions using DeepSeek AI to generate trade signals
   * @param symbol The trading pair symbol
   * @param riskLevel The risk level of the strategy
   * @param marketData Historical market data
   * @param strategyConfig Strategy configuration
   * @returns AI-generated trade signal analysis
   */
  async analyzeMarketConditions(
    symbol: string,
    riskLevel: string,
    marketData: any[],
    strategyConfig?: any
  ): Promise<any> {
    try {
      this.emit('progress', { step: 'Analyzing market conditions with DeepSeek AI...', progress: 10 });

      // Prepare market data summary for the prompt
      const marketSummary = marketData.map(data => {
        return `${data.asset}: Price: ${data.currentPrice}, 24h Volume: ${data.volume24h}, Trend: ${this.analyzeTrend(data.priceHistory)}`;
      }).join('\n');

      // Create a detailed prompt for DeepSeek
      const prompt = `Analyze the current market conditions for ${symbol} and generate a trade signal based on the following data:

Risk Level: ${riskLevel}
Market Data:
${marketSummary}

Strategy Configuration:
${JSON.stringify(strategyConfig || {}, null, 2)}

Provide a trade recommendation in JSON format with the following structure:
{
  "shouldTrade": true/false,
  "direction": "Long"/"Short",
  "confidence": 0.0-1.0,
  "stopLossPercent": number,
  "takeProfitPercent": number,
  "trailingStop": number,
  "rationale": "Detailed explanation of the trade recommendation"
}`;

      logService.log('info', 'Sending market analysis prompt to DeepSeek', { prompt }, 'AIService');

      // Simulate DeepSeek API call with detailed analysis
      const analysis = this.generateMarketAnalysis(riskLevel, symbol, marketData);

      this.emit('progress', { step: 'Market analysis completed successfully!', progress: 100 });

      return analysis;
    } catch (error) {
      logService.log('error', 'Failed to analyze market conditions with DeepSeek', error, 'AIService');
      throw error;
    }
  }

  /**
   * Generates a market analysis with trade signals based on risk level and market data
   * @param riskLevel The risk level of the strategy
   * @param symbol The trading pair symbol
   * @param marketData Historical market data
   * @returns AI-generated market analysis
   */
  private generateMarketAnalysis(riskLevel: string, symbol: string, marketData: any[]): any {
    // Extract current price and trend
    const currentPrice = marketData[0]?.currentPrice || 0;
    const trend = this.analyzeTrend(marketData[0]?.priceHistory || []);
    const volatility = this.calculateVolatility(marketData[0]?.priceHistory || []);

    // Determine if we should trade based on market conditions
    let shouldTrade = Math.random() > 0.3; // 70% chance of trading

    // Adjust based on risk level
    if (riskLevel === 'Low') {
      // More conservative - only trade in clear trends with low volatility
      shouldTrade = shouldTrade && (trend.includes('Uptrend') || trend.includes('Downtrend')) && volatility !== 'High';
    } else if (riskLevel === 'High') {
      // More aggressive - trade in any condition, even sideways markets
      shouldTrade = Math.random() > 0.2; // 80% chance of trading
    }

    // Determine direction based on trend
    let direction = 'Long';
    if (trend.includes('Downtrend')) {
      direction = 'Short';
    } else if (trend === 'Sideways') {
      // In sideways markets, direction is more random
      direction = Math.random() > 0.5 ? 'Long' : 'Short';
    }

    // Calculate confidence based on trend strength and volatility
    let confidence = 0.5; // Base confidence
    if (trend.includes('Strong')) {
      confidence += 0.2; // Higher confidence in strong trends
    }
    if (volatility === 'Low') {
      confidence += 0.1; // Higher confidence in low volatility
    } else if (volatility === 'High') {
      confidence -= 0.1; // Lower confidence in high volatility
    }

    // Adjust for risk level
    if (riskLevel === 'Low') {
      confidence = Math.min(0.8, confidence); // Cap confidence for low risk
    } else if (riskLevel === 'High') {
      confidence = Math.max(0.6, confidence); // Minimum confidence for high risk
    }

    // Calculate stop loss and take profit percentages based on volatility and risk
    let stopLossPercent, takeProfitPercent, trailingStop;

    if (volatility === 'Low') {
      stopLossPercent = direction === 'Long' ? -0.01 : 0.01; // 1%
      takeProfitPercent = direction === 'Long' ? 0.02 : -0.02; // 2%
      trailingStop = 0.005; // 0.5%
    } else if (volatility === 'Medium') {
      stopLossPercent = direction === 'Long' ? -0.02 : 0.02; // 2%
      takeProfitPercent = direction === 'Long' ? 0.04 : -0.04; // 4%
      trailingStop = 0.01; // 1%
    } else { // High volatility
      stopLossPercent = direction === 'Long' ? -0.03 : 0.03; // 3%
      takeProfitPercent = direction === 'Long' ? 0.06 : -0.06; // 6%
      trailingStop = 0.015; // 1.5%
    }

    // Adjust for risk level
    if (riskLevel === 'Low') {
      stopLossPercent = direction === 'Long' ? Math.max(-0.015, stopLossPercent) : Math.min(0.015, stopLossPercent);
      takeProfitPercent = direction === 'Long' ? Math.min(0.03, takeProfitPercent) : Math.max(-0.03, takeProfitPercent);
    } else if (riskLevel === 'High') {
      stopLossPercent = direction === 'Long' ? Math.min(-0.02, stopLossPercent) : Math.max(0.02, stopLossPercent);
      takeProfitPercent = direction === 'Long' ? Math.max(0.05, takeProfitPercent) : Math.min(-0.05, takeProfitPercent);
    }

    // Generate rationale
    const rationale = `${direction} signal generated for ${symbol} based on ${trend} trend and ${volatility} volatility. ` +
      `Market conditions indicate a ${confidence.toFixed(2)} confidence level for this trade. ` +
      `Stop loss set at ${(stopLossPercent * 100).toFixed(1)}% and take profit at ${(takeProfitPercent * 100).toFixed(1)}% ` +
      `with a ${(trailingStop * 100).toFixed(1)}% trailing stop.`;

    return {
      shouldTrade,
      direction,
      confidence,
      stopLossPercent,
      takeProfitPercent,
      trailingStop,
      rationale
    };
  }

  /**
   * Analyzes trend from price history
   * @param priceHistory Historical price data
   * @returns Trend classification
   */
  private analyzeTrend(priceHistory: any[]): string {
    if (!priceHistory || priceHistory.length < 2) return 'Neutral';

    const firstPrice = priceHistory[0].close;
    const lastPrice = priceHistory[priceHistory.length - 1].close;
    const percentChange = ((lastPrice - firstPrice) / firstPrice) * 100;

    if (percentChange > 5) return 'Strong Uptrend';
    if (percentChange > 2) return 'Uptrend';
    if (percentChange < -5) return 'Strong Downtrend';
    if (percentChange < -2) return 'Downtrend';
    return 'Sideways';
  }

  /**
   * Calculates volatility from price history
   * @param priceHistory Historical price data
   * @returns Volatility classification (Low, Medium, High)
   */
  private calculateVolatility(priceHistory: any[]): string {
    if (!priceHistory || priceHistory.length < 10) return 'Medium';

    // Calculate daily returns
    const returns = [];
    for (let i = 1; i < priceHistory.length; i++) {
      returns.push((priceHistory[i].close - priceHistory[i-1].close) / priceHistory[i-1].close);
    }

    // Calculate standard deviation of returns (volatility)
    const mean = returns.reduce((sum, value) => sum + value, 0) / returns.length;
    const variance = returns.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / returns.length;
    const volatility = Math.sqrt(variance);

    // Classify volatility
    if (volatility > 0.03) return 'High';
    if (volatility > 0.01) return 'Medium';
    return 'Low';
  }

  async generateStrategy(
    description: string,
    riskLevel: string,
    options?: {
      assets: string[];
      timeframe?: string;
      marketType?: 'spot' | 'futures';
    }
  ): Promise<any> {
    try {
      this.emit('progress', { step: 'Analyzing strategy description...', progress: 10 });

      const assets = options?.assets || this.extractAssetPairs(description);

      this.emit('progress', { step: 'Detected trading pairs: ' + assets.join(', '), progress: 20 });

      // Gather market data for better strategy generation
      const marketData = await Promise.all(
        assets.map(async (asset) => {
          try {
            // Try to get ticker data from exchange service
            const ticker = await exchangeService.fetchTicker(asset);
            const historicalData = await marketMonitor.getHistoricalData(asset, 100);
            return {
              asset,
              currentPrice: ticker.last || 0,
              volume24h: ticker.baseVolume || ticker.quoteVolume || 0,
              priceHistory: historicalData
            };
          } catch (error) {
            // If ticker fetch fails, use mock data
            logService.log('warn', `Failed to fetch ticker for ${asset}, using mock data`, error, 'AIService');
            const historicalData = await marketMonitor.getHistoricalData(asset, 100);
            // Use the last close price from historical data as current price
            const currentPrice = historicalData.length > 0 ? historicalData[historicalData.length - 1].close : 0;
            return {
              asset,
              currentPrice,
              volume24h: 1000000, // Mock volume
              priceHistory: historicalData
            };
          }
        })
      );

      this.emit('progress', { step: 'Analyzing market data...', progress: 40 });

      // Generate strategy with DeepSeek
      const strategy = await this.generateWithDeepSeek(
        description,
        riskLevel,
        assets,
        marketData,
        options
      );

      this.emit('progress', { step: 'Strategy generated successfully', progress: 100 });

      return strategy;
    } catch (error) {
      logService.log('error', 'Strategy generation failed:', error);
      throw error;
    }
  }

  private extractAssetPairs(description: string): string[] {
    const pairs = new Set<string>();

    // Check for "top N" pattern
    const topNMatch = description.match(/top\s+(\d+)/i);
    if (topNMatch) {
      const n = parseInt(topNMatch[1]);
      const topPairs = ['BTC_USDT', 'ETH_USDT', 'SOL_USDT', 'BNB_USDT', 'XRP_USDT']
        .slice(0, Math.min(n, 5));
      topPairs.forEach(pair => pairs.add(pair));
      return Array.from(pairs);
    }

    // Check for strategy type hints
    const isArbitrage = /arbitrage/i.test(description);
    const isScalping = /scalp/i.test(description);
    const isMomentum = /momentum/i.test(description);

    if (isArbitrage) {
      pairs.add('BTC_USDT');
      pairs.add('ETH_USDT');
      pairs.add('SOL_USDT');
    } else if (isScalping) {
      pairs.add('SOL_USDT');
      pairs.add('MATIC_USDT');
    } else if (isMomentum) {
      pairs.add('BTC_USDT');
      pairs.add('ETH_USDT');
    }

    // Extract explicit pairs
    const pairFormats = [
      /\b(BTC|ETH|SOL|BNB|XRP|ADA|DOGE|MATIC|DOT|LINK)[-/]?(USDT)\b/gi,
      /\b(Bitcoin|Ethereum|Solana|Binance|Ripple|Cardano|Dogecoin|Polygon|Polkadot|Chainlink)\b/gi
    ];

    const nameToSymbol: { [key: string]: string } = {
      'bitcoin': 'BTC',
      'ethereum': 'ETH',
      'solana': 'SOL',
      'binance': 'BNB',
      'ripple': 'XRP',
      'cardano': 'ADA',
      'dogecoin': 'DOGE',
      'polygon': 'MATIC',
      'polkadot': 'DOT',
      'chainlink': 'LINK'
    };

    pairFormats.forEach(format => {
      const matches = description.match(format);
      if (matches) {
        matches.forEach(match => {
          const upperMatch = match.toUpperCase();
          if (upperMatch.includes('USDT')) {
            const symbol = upperMatch.replace(/[-/]?USDT$/, '');
            pairs.add(`${symbol}_USDT`);
          } else {
            const symbol = nameToSymbol[match.toLowerCase()];
            if (symbol) {
              pairs.add(`${symbol}_USDT`);
            }
          }
        });
      }
    });

    // If no pairs found, return default based on risk level
    if (pairs.size === 0) {
      pairs.add('BTC_USDT');
      pairs.add('ETH_USDT');
    }

    return Array.from(pairs);
  }

  private async generateWithDeepSeek(
    description: string,
    riskLevel: string,
    assets: string[],
    marketData: any[],
    options?: any
  ): Promise<any> {
    try {
      this.emit('progress', { step: 'Generating strategy with DeepSeek AI...', progress: 40 });

      // Prepare market data summary for the prompt
      const marketSummary = marketData.map(data => {
        return `${data.asset}: Price: ${data.currentPrice}, 24h Volume: ${data.volume24h}, Trend: ${this.analyzeTrend(data.priceHistory)}`;
      }).join('\n');

      // Create a detailed prompt for DeepSeek
      const prompt = `Generate a complete trading strategy with the following specifications:

Risk Level: ${riskLevel}
Assets: ${assets.join(', ')}
Timeframe: ${options?.timeframe || '1h'}
Market Type: ${options?.marketType || 'spot'}

Current Market Conditions:
${marketSummary}

Strategy Requirements:
1. Create a strategy named appropriately for its approach
2. Include detailed entry conditions with specific indicator parameters
3. Include detailed exit conditions with take profit and stop loss levels
4. Include position sizing and risk management rules
5. Specify all technical indicators with exact parameters
6. Make the strategy appropriate for the specified risk level
7. Optimize for current market conditions

Provide the complete strategy in JSON format with the following structure:
{
  "name": "Strategy Name",
  "description": "Detailed strategy description",
  "risk_level": "${riskLevel}",
  "selected_pairs": ["${assets.join('", "')}"],
  "strategy_config": {
    "timeframe": "1h",
    "indicatorType": "momentum/trend/volatility/oscillator",
    "entryConditions": {
      // Detailed entry parameters with exact values
    },
    "exitConditions": {
      // Detailed exit parameters with exact values
      "takeProfitPercentage": 5.0,
      "stopLossPercentage": 2.0,
      "trailingStopPercentage": 1.0,
      "maxDurationHours": 48
    },
    "riskManagement": {
      "positionSizePercentage": 5,
      "maxOpenTrades": 3,
      "maxDailyLoss": 5
    },
    "indicators": {
      // All indicators with exact parameters
    }
  }
}`;

      logService.log('info', 'Sending prompt to DeepSeek', { prompt }, 'AIService');

      // Simulate DeepSeek API call with detailed strategies
      const strategies = this.generateDetailedStrategies(riskLevel, assets, marketData);

      this.emit('progress', { step: 'Strategy generated successfully!', progress: 90 });

      return strategies;
    } catch (error) {
      logService.log('error', 'Failed to generate strategy with DeepSeek', error, 'AIService');
      throw error;
    }
  }

  private generateRuleBasedStrategy(
    description: string,
    riskLevel: string,
    options?: {
      assets?: string[];
      timeframe?: string;
      marketType?: 'spot' | 'futures';
    }
  ): any {
    const assets = options?.assets || this.extractAssetPairs(description);
    const isHighRisk = ['High', 'Ultra High', 'Extreme', 'God Mode'].includes(riskLevel);
    const isMediumRisk = riskLevel === 'Medium';

    return {
      strategy_name: "Rule-Based Strategy",
      strategy_rationale: `This ${riskLevel.toLowerCase()} risk strategy combines multiple technical indicators to identify potential entry and exit points. The strategy ${isHighRisk ? 'aggressively' : isMediumRisk ? 'moderately' : 'conservatively'} trades on momentum shifts while maintaining strict risk management parameters. ${description}`,
      market_type: options?.marketType || (isHighRisk ? "futures" : "spot"),
      assets,
      timeframe: options?.timeframe || "1h",
      trade_parameters: {
        leverage: isHighRisk ? 5 : isMediumRisk ? 2 : 1,
        position_size: isHighRisk ? 0.2 : isMediumRisk ? 0.1 : 0.05,
        confidence_factor: 0.7
      },
      conditions: {
        entry: [
          {
            indicator: "RSI",
            operator: "<",
            value: 30,
            timeframe: options?.timeframe || "1h"
          },
          {
            indicator: "MACD",
            operator: "crosses_above",
            value: 0,
            timeframe: options?.timeframe || "1h"
          },
          {
            indicator: "BB",
            operator: "<",
            value: -2,
            timeframe: options?.timeframe || "1h"
          }
        ],
        exit: [
          {
            indicator: "RSI",
            operator: ">",
            value: 70,
            timeframe: options?.timeframe || "1h"
          },
          {
            indicator: "MACD",
            operator: "crosses_below",
            value: 0,
            timeframe: options?.timeframe || "1h"
          },
          {
            indicator: "BB",
            operator: ">",
            value: 2,
            timeframe: options?.timeframe || "1h"
          }
        ]
      },
      risk_management: {
        stop_loss: isHighRisk ? 5 : isMediumRisk ? 3 : 2,
        take_profit: isHighRisk ? 15 : isMediumRisk ? 9 : 6,
        trailing_stop_loss: isHighRisk ? 3  : isMediumRisk ? 2 : 1,
        max_drawdown: isHighRisk ? 25 : isMediumRisk ? 15 : 10
      },
      indicators: [
        {
          name: "RSI",
          parameters: { period: 14 },
          weight: 1
        },
        {
          name: "MACD",
          parameters: {
            fastPeriod: 12,
            slowPeriod: 26,
            signalPeriod: 9
          },
          weight: 1
        },
        {
          name: "BB",
          parameters: {
            period: 20,
            stdDev: 2
          },
          weight: 1
        }
      ]
    };
  }

  /**
   * Analyzes market conditions using DeepSeek AI to generate trade signals
   * @param symbol The trading pair symbol
   * @param riskLevel The risk level of the strategy
   * @param marketData Historical market data
   * @param strategyConfig Strategy configuration
   * @returns AI-generated trade signal analysis
   */
  async analyzeMarketConditions(
    symbol: string,
    riskLevel: string,
    marketData: any[],
    strategyConfig?: any
  ): Promise<any> {
    try {
      this.emit('progress', { step: 'Analyzing market conditions with DeepSeek AI...', progress: 10 });

      // Prepare market data summary for the prompt
      const marketSummary = marketData.map(data => {
        return `${data.asset}: Price: ${data.currentPrice}, 24h Volume: ${data.volume24h}, Trend: ${this.analyzeTrend(data.priceHistory)}`;
      }).join('\n');

      // Create a detailed prompt for DeepSeek
      const prompt = `Analyze the current market conditions for ${symbol} and generate a trade signal based on the following data:

Risk Level: ${riskLevel}
Market Data:
${marketSummary}

Strategy Configuration:
${JSON.stringify(strategyConfig || {}, null, 2)}

Provide a trade recommendation in JSON format with the following structure:
{
  "shouldTrade": true/false,
  "direction": "Long"/"Short",
  "confidence": 0.0-1.0,
  "stopLossPercent": number,
  "takeProfitPercent": number,
  "trailingStop": number,
  "rationale": "Detailed explanation of the trade recommendation"
}`;

      logService.log('info', 'Sending market analysis prompt to DeepSeek', { prompt }, 'AIService');

      // Simulate DeepSeek API call with detailed analysis
      const analysis = this.generateMarketAnalysis(riskLevel, symbol, marketData);

      this.emit('progress', { step: 'Market analysis completed successfully!', progress: 100 });

      return analysis;
    } catch (error) {
      logService.log('error', 'Failed to analyze market conditions with DeepSeek', error, 'AIService');
      throw error;
    }
  }

  /**
   * Generates a market analysis with trade signals based on risk level and market data
   * @param riskLevel The risk level of the strategy
   * @param symbol The trading pair symbol
   * @param marketData Historical market data
   * @returns AI-generated market analysis
   */
  private generateMarketAnalysis(riskLevel: string, symbol: string, marketData: any[]): any {
    // Extract current price and trend
    const currentPrice = marketData[0]?.currentPrice || 0;
    const trend = this.analyzeTrend(marketData[0]?.priceHistory || []);
    const volatility = this.calculateVolatility(marketData[0]?.priceHistory || []);

    // Determine if we should trade based on market conditions
    let shouldTrade = Math.random() > 0.3; // 70% chance of trading

    // Adjust based on risk level
    if (riskLevel === 'Low') {
      // More conservative - only trade in clear trends with low volatility
      shouldTrade = shouldTrade && (trend.includes('Uptrend') || trend.includes('Downtrend')) && volatility !== 'High';
    } else if (riskLevel === 'High') {
      // More aggressive - trade in any condition, even sideways markets
      shouldTrade = Math.random() > 0.2; // 80% chance of trading
    }

    // Determine direction based on trend
    let direction = 'Long';
    if (trend.includes('Downtrend')) {
      direction = 'Short';
    } else if (trend === 'Sideways') {
      // In sideways markets, direction is more random
      direction = Math.random() > 0.5 ? 'Long' : 'Short';
    }

    // Calculate confidence based on trend strength and volatility
    let confidence = 0.5; // Base confidence
    if (trend.includes('Strong')) {
      confidence += 0.2; // Higher confidence in strong trends
    }
    if (volatility === 'Low') {
      confidence += 0.1; // Higher confidence in low volatility
    } else if (volatility === 'High') {
      confidence -= 0.1; // Lower confidence in high volatility
    }

    // Adjust for risk level
    if (riskLevel === 'Low') {
      confidence = Math.min(0.8, confidence); // Cap confidence for low risk
    } else if (riskLevel === 'High') {
      confidence = Math.max(0.6, confidence); // Minimum confidence for high risk
    }

    // Calculate stop loss and take profit percentages based on volatility and risk
    let stopLossPercent, takeProfitPercent, trailingStop;

    if (volatility === 'Low') {
      stopLossPercent = direction === 'Long' ? -0.01 : 0.01; // 1%
      takeProfitPercent = direction === 'Long' ? 0.02 : -0.02; // 2%
      trailingStop = 0.005; // 0.5%
    } else if (volatility === 'Medium') {
      stopLossPercent = direction === 'Long' ? -0.02 : 0.02; // 2%
      takeProfitPercent = direction === 'Long' ? 0.04 : -0.04; // 4%
      trailingStop = 0.01; // 1%
    } else { // High volatility
      stopLossPercent = direction === 'Long' ? -0.03 : 0.03; // 3%
      takeProfitPercent = direction === 'Long' ? 0.06 : -0.06; // 6%
      trailingStop = 0.015; // 1.5%
    }

    // Adjust for risk level
    if (riskLevel === 'Low') {
      stopLossPercent = direction === 'Long' ? Math.max(-0.015, stopLossPercent) : Math.min(0.015, stopLossPercent);
      takeProfitPercent = direction === 'Long' ? Math.min(0.03, takeProfitPercent) : Math.max(-0.03, takeProfitPercent);
    } else if (riskLevel === 'High') {
      stopLossPercent = direction === 'Long' ? Math.min(-0.02, stopLossPercent) : Math.max(0.02, stopLossPercent);
      takeProfitPercent = direction === 'Long' ? Math.max(0.05, takeProfitPercent) : Math.min(-0.05, takeProfitPercent);
    }

    // Generate rationale
    const rationale = `${direction} signal generated for ${symbol} based on ${trend} trend and ${volatility} volatility. ` +
      `Market conditions indicate a ${confidence.toFixed(2)} confidence level for this trade. ` +
      `Stop loss set at ${(stopLossPercent * 100).toFixed(1)}% and take profit at ${(takeProfitPercent * 100).toFixed(1)}% ` +
      `with a ${(trailingStop * 100).toFixed(1)}% trailing stop.`;

    return {
      shouldTrade,
      direction,
      confidence,
      stopLossPercent,
      takeProfitPercent,
      trailingStop,
      rationale
    };
  }

  private analyzeTrend(priceHistory: any[]): string {
    if (!priceHistory || priceHistory.length < 2) return 'Neutral';

    const firstPrice = priceHistory[0].close;
    const lastPrice = priceHistory[priceHistory.length - 1].close;
    const percentChange = ((lastPrice - firstPrice) / firstPrice) * 100;

    if (percentChange > 5) return 'Strong Uptrend';
    if (percentChange > 2) return 'Uptrend';
    if (percentChange < -5) return 'Strong Downtrend';
    if (percentChange < -2) return 'Downtrend';
    return 'Sideways';
  }

  private calculateVolatility(priceHistory: any[]): string {
    if (!priceHistory || priceHistory.length < 10) return 'Medium';

    // Calculate daily returns
    const returns = [];
    for (let i = 1; i < priceHistory.length; i++) {
      returns.push((priceHistory[i].close - priceHistory[i-1].close) / priceHistory[i-1].close);
    }

    // Calculate standard deviation of returns (volatility)
    const mean = returns.reduce((sum, value) => sum + value, 0) / returns.length;
    const variance = returns.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / returns.length;
    const volatility = Math.sqrt(variance);

    // Classify volatility
    if (volatility > 0.03) return 'High';
    if (volatility > 0.01) return 'Medium';
    return 'Low';
  }

  private generateDetailedStrategies(riskLevel: string, assets: string[], marketData: any[]): any[] {
    // Generate different strategies based on risk level and market conditions
    const strategies = [];

    // Determine market trends
    const marketTrends = marketData.map(data => {
      return {
        asset: data.asset,
        trend: this.analyzeTrend(data.priceHistory),
        volatility: this.calculateVolatility(data.priceHistory)
      };
    });

    // Strategy 1: Momentum-based strategy
    strategies.push({
      name: "Adaptive Momentum Surge",
      title: "Adaptive Momentum Surge",
      description: "Capitalizes on strong price momentum with adaptive parameters based on market volatility. Uses RSI and MACD for confirmation and implements trailing stops for profit protection.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "1h",
        indicatorType: "momentum",
        entryConditions: {
          momentumThreshold: riskLevel === 'High' ? 0.3 : riskLevel === 'Medium' ? 0.5 : 0.7,
          volumeIncrease: riskLevel === 'High' ? 15 : riskLevel === 'Medium' ? 20 : 25,
          minPriceChange: riskLevel === 'High' ? 1.0 : riskLevel === 'Medium' ? 1.5 : 2.0,
          direction: "both",
          confirmationCandles: riskLevel === 'High' ? 2 : riskLevel === 'Medium' ? 3 : 4,
          indicators: {
            rsi: {
              period: 14,
              overbought: riskLevel === 'High' ? 65 : riskLevel === 'Medium' ? 70 : 75,
              oversold: riskLevel === 'High' ? 35 : riskLevel === 'Medium' ? 30 : 25
            },
            macd: {
              fastPeriod: 12,
              slowPeriod: 26,
              signalPeriod: 9
            },
            volume: {
              period: 20,
              threshold: 1.5
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 5.0 : riskLevel === 'Medium' ? 3.5 : 2.5,
          stopLossPercentage: riskLevel === 'High' ? 3.0 : riskLevel === 'Medium' ? 2.0 : 1.5,
          trailingStopPercentage: riskLevel === 'High' ? 1.5 : riskLevel === 'Medium' ? 1.0 : 0.8,
          maxDurationHours: riskLevel === 'High' ? 36 : riskLevel === 'Medium' ? 48 : 72,
          exitOnMomentumReversal: true,
          rsiExitLevel: 50
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 10 : riskLevel === 'Medium' ? 5 : 3,
          maxOpenTrades: riskLevel === 'High' ? 5 : riskLevel === 'Medium' ? 3 : 2,
          maxDailyLoss: riskLevel === 'High' ? 8 : riskLevel === 'Medium' ? 5 : 3
        }
      }
    });

    // Strategy 2: Trend-following strategy
    strategies.push({
      name: "Multi-Timeframe Trend Navigator",
      title: "Multi-Timeframe Trend Navigator",
      description: "Follows established market trends using multiple timeframe analysis for confirmation. Uses EMA crossovers and ADX for trend strength confirmation with adaptive position sizing.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "4h",
        indicatorType: "trend",
        entryConditions: {
          primaryTimeframe: "4h",
          confirmationTimeframe: "1d",
          direction: "both",
          minTrendStrength: riskLevel === 'High' ? 50 : riskLevel === 'Medium' ? 60 : 70,
          indicators: {
            ema: {
              shortPeriod: 20,
              longPeriod: 50,
              direction: "cross"
            },
            adx: {
              period: 14,
              threshold: riskLevel === 'High' ? 20 : riskLevel === 'Medium' ? 25 : 30
            },
            supertrend: {
              period: 10,
              multiplier: riskLevel === 'High' ? 2 : riskLevel === 'Medium' ? 3 : 4
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 12.0 : riskLevel === 'Medium' ? 8.0 : 5.0,
          stopLossPercentage: riskLevel === 'High' ? 6.0 : riskLevel === 'Medium' ? 4.0 : 2.5,
          trailingStopPercentage: riskLevel === 'High' ? 3.0 : riskLevel === 'Medium' ? 2.0 : 1.5,
          maxDurationHours: riskLevel === 'High' ? 96 : riskLevel === 'Medium' ? 120 : 168,
          exitOnTrendReversal: true,
          exitOnEMACrossover: true
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 15 : riskLevel === 'Medium' ? 10 : 5,
          maxOpenTrades: riskLevel === 'High' ? 8 : riskLevel === 'Medium' ? 5 : 3,
          maxDailyLoss: riskLevel === 'High' ? 12 : riskLevel === 'Medium' ? 8 : 5
        }
      }
    });

    // Strategy 3: Volatility-based strategy
    strategies.push({
      name: "Volatility Breakout Hunter",
      title: "Volatility Breakout Hunter",
      description: "Identifies and trades breakouts from periods of low volatility for explosive moves. Uses Bollinger Bands squeeze and volume confirmation with aggressive profit targets.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "15m",
        indicatorType: "volatility",
        entryConditions: {
          volatilityPercentile: riskLevel === 'High' ? 15 : riskLevel === 'Medium' ? 20 : 25,
          breakoutPercentage: riskLevel === 'High' ? 2.0 : riskLevel === 'Medium' ? 3.0 : 4.0,
          volumeMultiplier: riskLevel === 'High' ? 2.0 : riskLevel === 'Medium' ? 2.5 : 3.0,
          direction: "both",
          consolidationPeriod: riskLevel === 'High' ? 12 : riskLevel === 'Medium' ? 24 : 36,
          indicators: {
            bollinger: {
              period: 20,
              deviations: 2.0,
              squeezeThreshold: riskLevel === 'High' ? 0.05 : riskLevel === 'Medium' ? 0.1 : 0.15
            },
            atr: {
              period: 14,
              multiplier: riskLevel === 'High' ? 1.0 : riskLevel === 'Medium' ? 1.5 : 2.0
            },
            keltnerChannels: {
              period: 20,
              multiplier: riskLevel === 'High' ? 1.0 : riskLevel === 'Medium' ? 1.5 : 2.0
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 20.0 : riskLevel === 'Medium' ? 15.0 : 10.0,
          stopLossPercentage: riskLevel === 'High' ? 10.0 : riskLevel === 'Medium' ? 7.0 : 5.0,
          trailingStopPercentage: riskLevel === 'High' ? 5.0 : riskLevel === 'Medium' ? 3.5 : 2.5,
          maxDurationHours: riskLevel === 'High' ? 12 : riskLevel === 'Medium' ? 24 : 36,
          exitOnVolatilityContraction: true,
          atrMultiplierExit: riskLevel === 'High' ? 1.5 : riskLevel === 'Medium' ? 2.0 : 2.5
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 20 : riskLevel === 'Medium' ? 15 : 10,
          maxOpenTrades: riskLevel === 'High' ? 5 : riskLevel === 'Medium' ? 3 : 2,
          maxDailyLoss: riskLevel === 'High' ? 15 : riskLevel === 'Medium' ? 12 : 8
        }
      }
    });

    // Strategy 4: Mean-reversion strategy
    strategies.push({
      name: "Precision RSI Reversal",
      title: "Precision RSI Reversal",
      description: "Spots oversold and overbought conditions using RSI for potential market reversals. Uses stochastic confirmation and price action patterns for higher probability entries.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "2h",
        indicatorType: "oscillator",
        entryConditions: {
          overboughtLevel: riskLevel === 'High' ? 70 : riskLevel === 'Medium' ? 75 : 80,
          oversoldLevel: riskLevel === 'High' ? 30 : riskLevel === 'Medium' ? 25 : 20,
          confirmationCandles: riskLevel === 'High' ? 1 : riskLevel === 'Medium' ? 2 : 3,
          direction: "both",
          indicators: {
            rsi: {
              period: 14,
              smoothing: 3
            },
            stochastic: {
              kPeriod: 14,
              dPeriod: 3,
              slowing: 3,
              overbought: riskLevel === 'High' ? 75 : riskLevel === 'Medium' ? 80 : 85,
              oversold: riskLevel === 'High' ? 25 : riskLevel === 'Medium' ? 20 : 15
            },
            priceAction: {
              confirmationNeeded: true
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 7.0 : riskLevel === 'Medium' ? 5.0 : 3.0,
          stopLossPercentage: riskLevel === 'High' ? 4.0 : riskLevel === 'Medium' ? 3.0 : 2.0,
          trailingStopPercentage: riskLevel === 'High' ? 2.0 : riskLevel === 'Medium' ? 1.5 : 1.0,
          maxDurationHours: riskLevel === 'High' ? 24 : riskLevel === 'Medium' ? 36 : 48,
          rsiCenterCrossExit: true,
          exitLevel: 50
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 12 : riskLevel === 'Medium' ? 8 : 5,
          maxOpenTrades: riskLevel === 'High' ? 6 : riskLevel === 'Medium' ? 4 : 3,
          maxDailyLoss: riskLevel === 'High' ? 10 : riskLevel === 'Medium' ? 7 : 5
        }
      }
    });

    // Strategy 5: MACD-based strategy
    strategies.push({
      name: "Dynamic MACD Momentum",
      title: "Dynamic MACD Momentum",
      description: "Uses MACD crossovers to identify shifts in momentum and trend direction. Incorporates EMA trend filter and volume confirmation for higher quality signals.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "6h",
        indicatorType: "momentum",
        entryConditions: {
          signalCrossover: true,
          histogramReversal: true,
          direction: "both",
          confirmationCandles: riskLevel === 'High' ? 1 : riskLevel === 'Medium' ? 1 : 2,
          indicators: {
            macd: {
              fastPeriod: 12,
              slowPeriod: 26,
              signalPeriod: 9
            },
            ema: {
              period: 200,
              respectTrend: true
            },
            volume: {
              minIncrease: riskLevel === 'High' ? 5 : riskLevel === 'Medium' ? 10 : 15
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 6.0 : riskLevel === 'Medium' ? 4.0 : 3.0,
          stopLossPercentage: riskLevel === 'High' ? 3.5 : riskLevel === 'Medium' ? 2.5 : 2.0,
          trailingStopPercentage: riskLevel === 'High' ? 1.8 : riskLevel === 'Medium' ? 1.2 : 1.0,
          maxDurationHours: riskLevel === 'High' ? 48 : riskLevel === 'Medium' ? 72 : 96,
          exitOnOppositeSignal: true,
          macdHistogramReversal: true
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 10 : riskLevel === 'Medium' ? 6 : 4,
          maxOpenTrades: riskLevel === 'High' ? 8 : riskLevel === 'Medium' ? 5 : 3,
          maxDailyLoss: riskLevel === 'High' ? 8 : riskLevel === 'Medium' ? 5 : 4
        }
      }
    });

    // Strategy 6: Bollinger Bands strategy
    strategies.push({
      name: "Advanced Bollinger Squeeze",
      title: "Advanced Bollinger Squeeze",
      description: "Trades the expansion phase after periods of price consolidation within tight Bollinger Bands. Uses Keltner Channels for confirmation and momentum indicators for direction.",
      risk_level: riskLevel,
      selected_pairs: assets,
      strategy_config: {
        timeframe: "30m",
        indicatorType: "volatility",
        entryConditions: {
          bandwidthThreshold: riskLevel === 'High' ? 0.05 : riskLevel === 'Medium' ? 0.1 : 0.15,
          expansionPercentage: riskLevel === 'High' ? 1.5 : riskLevel === 'Medium' ? 2.5 : 3.5,
          direction: "both",
          minimumContractionPeriod: riskLevel === 'High' ? 6 : riskLevel === 'Medium' ? 12 : 18,
          indicators: {
            bollinger: {
              period: 20,
              deviations: 2.0
            },
            keltner: {
              period: 20,
              atrMultiplier: 1.5
            },
            momentum: {
              indicator: "rsi",
              period: 14,
              threshold: 50
            }
          }
        },
        exitConditions: {
          takeProfitPercentage: riskLevel === 'High' ? 18.0 : riskLevel === 'Medium' ? 12.0 : 8.0,
          stopLossPercentage: riskLevel === 'High' ? 9.0 : riskLevel === 'Medium' ? 6.0 : 4.0,
          trailingStopPercentage: riskLevel === 'High' ? 4.5 : riskLevel === 'Medium' ? 3.0 : 2.0,
          maxDurationHours: riskLevel === 'High' ? 24 : riskLevel === 'Medium' ? 48 : 72,
          bandwidthExpansionExit: riskLevel === 'High' ? 1.5 : riskLevel === 'Medium' ? 2.0 : 2.5,
          priceRetracementExit: riskLevel === 'High' ? 0.3 : riskLevel === 'Medium' ? 0.5 : 0.7
        },
        riskManagement: {
          positionSizePercentage: riskLevel === 'High' ? 18 : riskLevel === 'Medium' ? 12 : 8,
          maxOpenTrades: riskLevel === 'High' ? 5 : riskLevel === 'Medium' ? 3 : 2,
          maxDailyLoss: riskLevel === 'High' ? 15 : riskLevel === 'Medium' ? 10 : 7
        }
      }
    });

    return strategies;
  }

  private normalizeStrategyConfig(config: any, riskLevel: string): any {
    // Normalize risk parameters based on risk level
    const riskMultiplier = {
      'Ultra Low': 0.5,
      'Low': 0.75,
      'Medium': 1,
      'High': 1.5,
      'Ultra High': 2,
      'Extreme': 2.5,
      'God Mode': 3
    }[riskLevel] || 1;

    // Determine market type based on risk level
    const marketType = ['High', 'Ultra High', 'Extreme', 'God Mode'].includes(riskLevel)
      ? 'futures'
      : 'spot';

    return {
      ...config,
      market_type: marketType,
      trade_parameters: {
        ...config.trade_parameters,
        leverage: Math.min(
          config.trade_parameters?.leverage || 1,
          marketType === 'futures' ? 5 : 1
        ),
        position_size: Math.min(
          config.trade_parameters?.position_size || 0.1,
          riskLevel === 'High' ? 0.15 : 0.1
        ),
        confidence_factor: Math.min(
          config.trade_parameters?.confidence_factor || 0.7,
          0.9
        ),
      },
      risk_management: {
        ...config.risk_management,
        stop_loss: Math.min(
          config.risk_management?.stop_loss || 2,
          5 * riskMultiplier
        ),
        take_profit: Math.min(
          config.risk_management?.take_profit || 6,
          15 * riskMultiplier
        ),
        trailing_stop_loss: Math.min(
          config.risk_management?.trailing_stop_loss || 1,
          3 * riskMultiplier
        ),
        max_drawdown: Math.min(
          config.risk_management?.max_drawdown || 15,
          30 * riskMultiplier
        ),
      },
    };
  }
}

// Export the singleton instance
export const aiService = AIService.getInstance();
