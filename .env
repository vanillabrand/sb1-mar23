VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdzdWlzZXJiem9lYmNkcHRnbHptIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM0MjE1MzgsImV4cCI6MjA1ODk5NzUzOH0.kSsWOfPW7RI3IXbCUzXi9oKK0zSC__-6p6ukfDJbk-k
VITE_SUPABASE_URL=https://gsuiserbzoebcdptglzm.supabase.co
VITE_DEEPSEEK_API_KEY=sk-d218e91b203f45ebb4ede94cbed76478
VITE_ENCRYPTION_KEY=L9UBQ5lv6uxxCYyHFQbEljmQEmTTdD70p7woiZSHTvQ=

VITE_PROXY_URL=http://localhost:3001/api/

# Binance TestNet API keys for demo mode
BINANCE_TESTNET_API_KEY=cpFfnzgrDPTUeqp8gKLezbKFshZ72LN2AfcXNOyEMgbBGHEM5MXNpqZyGqNcT4Mb
BINANCE_TESTNET_API_SECRET=VMHP0k9XHuAakiNzbU1f5kAsUfO422R5fpIehwVok2U2gnu8xeNSjVA0ONuOHvN0

# Demo Exchange Credentials
VITE_DEMO_EXCHANGE_API_KEY=9971bb39db87369d2f9e03de5aa3e7c1691f64ca
VITE_DEMO_EXCHANGE_SECRET=6c38ef1698b82c1308d573373cf0faab6ea2c7269843c0f7bd0cb2e59a8e0359
VITE_DEMO_EXCHANGE_MEMO=Kebab


VITE_BINANCE_TEST_API_KEY=cpFfnzgrDPTUeqp8gKLezbKFshZ72LN2AfcXNOyEMgbBGHEM5MXNpqZyGqNcT4Mb
VITE_BINANCE_TEST_API_SECRET=VMHP0k9XHuAakiNzbU1f5kAsUfO422R5fpIehwVok2U2gnu8xeNSjVA0ONuOHvN0

# Also add non-prefixed versions for Node.js environment
BINANCE_TEST_API_KEY=cpFfnzgrDPTUeqp8gKLezbKFshZ72LN2AfcXNOyEMgbBGHEM5MXNpqZyGqNcT4Mb
BINANCE_TEST_API_SECRET=VMHP0k9XHuAakiNzbU1f5kAsUfO422R5fpIehwVok2U2gnu8xeNSjVA0ONuOHvN0

PORT=3000
NODE_ENV=development
TRADING_ENABLED=true
MAX_STRATEGIES_PER_PROCESS=10
HEALTH_CHECK_INTERVAL=30000
MARKET_FIT_CHECK_INTERVAL=14400000
RECOVERY_ATTEMPTS=3
NODE_DEBUG=false


# Exchange API Base URLs

# Binance
BINANCE_BASE_URL=https://api.binance.com
BINANCE_TESTNET_BASE_URL=https://testnet.binance.vision

# Coinbase Pro
COINBASE_BASE_URL=https://api.exchange.coinbase.com
COINBASE_SANDBOX_URL=https://api-public.sandbox.exchange.coinbase.com

# Kraken
KRAKEN_BASE_URL=https://api.kraken.com
KRAKEN_FUTURES_URL=https://futures.kraken.com

# Bitfinex
BITFINEX_BASE_URL=https://api.bitfinex.com
BITFINEX_TESTNET_URL=https://api-pub.bitfinex.com

# KuCoin
KUCOIN_BASE_URL=https://api.kucoin.com
KUCOIN_SANDBOX_URL=https://openapi-sandbox.kucoin.com

# Bybit
BYBIT_BASE_URL=https://api.bybit.com
BYBIT_TESTNET_URL=https://api-testnet.bybit.com

# Exchange API Keys (fill these with your actual keys)

# Binance API Keys
BINANCE_API_KEY=your_binance_api_key
BINANCE_API_SECRET=your_binance_api_secret

# Binance TestNet API Keys (for demo mode)
BINANCE_TESTNET_API_KEY=pFfnzgrDPTUeqp8gKLezbKFshZ72LN2AfcXNOyEMgbBGHEM5MXNpqZyGqNcT4Mb
BINANCE_TESTNET_API_SECRET=VMHP0k9XHuAakiNzbU1f5kAsUfO422R5fpIehwVok2U2gnu8xeNSjVA0ONuOHvN0

# Coinbase Pro API Keys
COINBASE_API_KEY=your_coinbase_api_key
COINBASE_API_SECRET=your_coinbase_api_secret
COINBASE_PASSPHRASE=your_coinbase_passphrase

# Other exchange keys as needed...

# Demo Mode Configuration
DEMO_MODE_ENABLED=true
DEFAULT_DEMO_EXCHANGE=binance
import json
import logging
import redis
import asyncio
from typing import List, Dict, Optional
from datetime import datetime
from enum import Enum

class TradeState(Enum):
    PENDING = "pending"
    ACTIVE = "active"
    CLOSED = "closed"
    CANCELLED = "cancelled"
    FAILED = "failed"

class TradeManager:
    """
    Manages the lifecycle of trades, including recording, updating, retrieving, transitioning,
    archiving, and closing trades. Supports handling both pending and active trades with advanced states.
    """

    def __init__(self, redis_host="localhost", redis_port=6379, redis_db=0):
        self.redis_client = redis.StrictRedis(
            host=redis_host,
            port=redis_port,
            db=redis_db,
            decode_responses=True
        )
        self.logger = logging.getLogger(self.__class__.__name__)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        self.open_trades = []
        self.closed_trades = []

    ### --- Utility Methods ---

    def _fetch_trades_by_ids(self, trade_ids: List[str]) -> List[Dict]:
        """
        Fetches trade data for multiple trade IDs in one Redis call.
        """
        try:
            pipeline = self.redis_client.pipeline()
            for trade_id in trade_ids:
                pipeline.hgetall(f"trade:{trade_id}")
            return pipeline.execute()
        except Exception as e:
            self.logger.error(f"Failed to fetch trades by IDs: {e}")
            return []

    def _update_trade_status(self, trade_id: str, new_status: str):
        """
        Updates the status of a trade.
        """
        key = f"trade:{trade_id}"
        if self.redis_client.exists(key):
            self.redis_client.hset(key, "status", new_status)
            self.logger.info(f"Trade {trade_id} status updated to {new_status}.")
        else:
            self.logger.error(f"Trade {trade_id} does not exist.")

    ### --- Trade Recording and State Management ---

    def record_trade(self, trade_data: Dict) -> Optional[str]:
        """Records a new trade in Redis."""
        try:
            trade_id = trade_data.get('trade_id', f"trade:{datetime.now().strftime('%Y%m%d%H%M%S')}")
            # Set defaults for new fields
            trade_data.setdefault('exchange_order_id', '')  # ID from exchange (once placed)
            trade_data.setdefault('filled_quantity', 0)
            trade_data.setdefault('fee_amount', 0)
            trade_data.setdefault('last_synced_at', '')
            trade_data.update({
                'created_at': datetime.now().isoformat(),
                'updated_at': datetime.now().isoformat(),
                'status': TradeState.PENDING.value,
                'retry_count': 0
            })
            self.redis_client.hmset(f"trade:{trade_id}", trade_data)
            self.redis_client.sadd("pending_trades", trade_id)
            self.redis_client.sadd(f"strategy:{trade_data['strategy_id']}:trades", trade_id)
            return trade_id
        except Exception as e:
            self.logger.error(f"Failed to record trade: {e}")
            return None

    def add_trade(self, trade_data: Dict) -> Optional[str]:
        """Adds a new trade to the system."""
        try:
            trade_id = self.record_trade(trade_data)
            if trade_id:
                self.logger.info(f"Trade {trade_id} added successfully.")
                return trade_id
        except Exception as e:
            self.logger.error(f"Failed to add trade: {e}")
        return None

    def cancel_trade(self, trade_id: str):
        """Cancels a pending trade."""
        self.transition_trade(trade_id, "pending_trades", "cancelled_trades", TradeState.CANCELLED.value)

    def close_trade(self, trade_id: str):
        """Closes an active trade."""
        self.transition_trade(trade_id, "active_trades", "closed_trades", TradeState.CLOSED.value)

    def add_failed_trade(self, trade_data: Dict):
        """Requeues failed trade with retry logic."""
        try:
            trade_id = trade_data["trade_id"]
            retry_count = trade_data.get("retry_count", 0) + 1
            if retry_count > 3:
                trade_data["status"] = TradeState.FAILED.value
                self.redis_client.hmset(f"trade:{trade_id}", trade_data)
                self.redis_client.srem("pending_trades", trade_id)
                self.redis_client.sadd("failed_trades", trade_id)
                self.logger.error(f"Trade {trade_id} exceeded max retries")
                return
            trade_data.update({
                "status": TradeState.PENDING.value,
                "retry_count": retry_count,
                "last_retry": datetime.now().isoformat()
            })
            self.redis_client.hmset(f"trade:{trade_id}", trade_data)
            self.redis_client.sadd("pending_trades", trade_id)
            self.logger.warning(f"Requeued failed trade: {trade_id}. Retry: {retry_count}/3")
        except Exception as e:
            self.logger.error(f"Failed to requeue trade {trade_id}: {e}")

    def transition_trade(self, trade_id: str, from_set: str, to_set: str, new_status: str):
        """Manages trade state transitions."""
        key = f"trade:{trade_id}"
        try:
            if not self.redis_client.exists(key):
                raise ValueError(f"Trade {trade_id} not found")
            self.redis_client.srem(from_set, trade_id)
            self.redis_client.sadd(to_set, trade_id)
            self.redis_client.hset(key, "status", new_status)
            self.redis_client.hset(key, "updated_at", datetime.now().isoformat())
        except Exception as e:
            self.logger.error(f"Failed to transition trade {trade_id}: {e}")
            raise

    def transition_to_active(self, trade_id: str):
        """
        Moves a trade from pending to active status.
        """
        self.transition_trade(trade_id, "pending_trades", "active_trades", TradeState.ACTIVE.value)

    def transition_to_closed(self, trade_id: str):
        """
        Moves a trade to the closed state.
        """
        self.transition_trade(trade_id, "active_trades", "closed_trades", TradeState.CLOSED.value)

    def archive_trade(self, trade_id: str):
        """
        Archives a trade and removes it from active storage.
        """
        key = f"trade:{trade_id}"
        archive_key = f"archive:trade:{trade_id}"
        try:
            if self.redis_client.exists(key):
                trade_data = self.redis_client.hgetall(key)
                self.redis_client.set(archive_key, json.dumps(trade_data))
                self.redis_client.delete(key)
                self.logger.info(f"Trade {trade_id} archived successfully.")
            else:
                self.logger.error(f"Trade ID '{trade_id}' does not exist.")
        except Exception as e:
            self.logger.error(f"Failed to archive trade {trade_id}: {e}")

    ### --- Trade Retrieval and Monitoring ---

    def get_active_trades(self) -> List[Dict]:
        """
        Retrieves all active trades from the database.
        """
        try:
            trade_ids = self.redis_client.smembers("active_trades")
            trades = self._fetch_trades_by_ids(list(trade_ids))
            return trades
        except Exception as e:
            self.logger.error(f"Failed to retrieve active trades: {e}")
            return []

    def get_pending_trades(self) -> List[Dict]:
        """
        Retrieves all pending trades from the database.
        """
        try:
            trade_ids = self.redis_client.smembers("pending_trades")
            trades = self._fetch_trades_by_ids(list(trade_ids))
            return trades
        except Exception as e:
            self.logger.error(f"Failed to retrieve pending trades: {e}")
            return []

    def get_trade(self, trade_id: str) -> Optional[Dict]:
        """Retrieves trade by ID."""
        try:
            trade = self.redis_client.hgetall(f"trade:{trade_id}")
            return trade if trade else None
        except Exception as e:
            self.logger.error(f"Failed to get trade {trade_id}: {e}")
            return None

    def update_trade(self, trade_id: str, updates: Dict) -> bool:
        """Updates existing trade."""
        try:
            updates['updated_at'] = datetime.now().isoformat()
            self.redis_client.hmset(f"trade:{trade_id}", updates)
            return True
        except Exception as e:
            self.logger.error(f"Failed to update trade {trade_id}: {e}")
            return False

    def get_strategy_trades(self, strategy_id: str, status: Optional[str] = None) -> List[Dict]:
        """Retrieves all trades for a strategy."""
        try:
            trade_ids = self.redis_client.smembers(f"strategy:{strategy_id}:trades")
            trades = self._fetch_trades_by_ids(list(trade_ids))
            if status:
                trades = [t for t in trades if t.get('status') == status]
            return trades
        except Exception as e:
            self.logger.error(f"Failed to get strategy trades: {e}")
            return []

    def close_strategy_trades(self, strategy_id: str) -> bool:
        """Closes all active trades for a strategy."""
        try:
            active_trades = self.get_strategy_trades(strategy_id, TradeState.ACTIVE.value)
            for trade in active_trades:
                self.transition_trade(
                    trade['trade_id'],
                    "active_trades",
                    "closed_trades",
                    TradeState.CLOSED.value
                )
            return True
        except Exception as e:
            self.logger.error(f"Failed to close strategy trades: {e}")
            return False

    def get_trade_performance(self, trade_id: str) -> Dict:
        """Calculates trade performance metrics."""
        try:
            trade = self.get_trade(trade_id)
            if not trade:
                return {}
            entry_price = float(trade['entry_price'])
            current_price = float(trade['current_price'])
            position_size = float(trade['amount'])
            pnl = (current_price - entry_price) * position_size if trade['side'] == 'buy' \
                else (entry_price - current_price) * position_size
            return {
                'pnl': pnl,
                'roi': (pnl / (entry_price * position_size)) * 100,
                'duration': (datetime.now() - datetime.fromisoformat(trade['created_at']))
